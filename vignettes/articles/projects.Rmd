---
title: "Établir une liste des projets en se basant sur les rapports de laboratoire"
author: "Steve Vissault"
date: "2024-03-19"
output: 
  html_document:
    highlight: tango
    theme: lumen
    toc: true
    toc_float: true
---

## Établir une liste exhaustive des rapports de laboratoire

Pourquoi? Chaque rapport contient sur sa page de garde l'ensemble des métadonnées en lien avec le projet de recherche pour lequel l'analyse a été demandé.

Un rapport de laboratoire peut être detectable dans une liste de fichier par la structure de son identifiant unique. Voici un exemple d'identifiant unique: `CHEM-PCDD-00-07` ou encore `MB-05-10`. Ces identifiants ont une structure unique que l'on peut detecter grace à l'expression régulière suivante:

```{R}
regex_report_id <- "([A-Za-z]{2,5}-)?[A-Za-z]{2,5}-\\d{2}-\\d{2}"
```

Cette expression régulière sera utilisée plusieurs fois dans ce document. 

On liste les rapports de laboratoire présents dans le dossier `03-Labo/Results Reports`.

```{R}
reports_path <- list.files(
    "C:/Users/VissaultS/Documents/03-Labo/Results Reports", 
    pattern = "*.pdf|*.docx|*.doc", recursive = TRUE, full.names = TRUE
)

# On extrait les identifiants des rapports du nom du fichier
report_id <- stringr::str_extract(reports_path, regex_report_id)

# On obtient la signature du fichier, ca va être pratique pour detecter les fichiers dupliqués même si le nom du fichier est différent.
file_hash <- tools::md5sum(reports_path)

# On extrait l'extension du fichier
file_ext <- reports_path |> 
    strsplit("[.]") |> 
    purrr::map_chr(\(e) return(e[2]))

# On compose un tableau avec l'ensemble de ces informations
reports <- data.frame(
        path = reports_path, 
        id = report_id, 
        hash = file_hash, 
        ext = file_ext
    ) |> tibble::as_tibble()
```

Note: `tools::md5sum` permet de générer une signature unique propre au fichier. Ainsi deux fichiers identiques dans le contenu mais avec des noms différents pourront être identifié comme des duplicats.

Voici la liste des fichiers identiques dans le dossier `03-Labo/Results Reports`.

```{R, results='asis'}
reports_dup <- reports |> 
    tibble::as_tibble() |>
    janitor::get_dupes(-c(path)) |>
    dplyr::select(-hash)

reports_dup |> knitr::kable()
```

On selectionne le premier rapport en se basant sur le id (ex. BMK-PFC-23-01) pour éliminer les rapports dupliqués pour la suite de l'analyse. On s'assure de selectionner préférablement les pdfs si on dispose d'un docx et d'un document pdf pour le même identifiant de rapport de laboratoire.

```{R}
reports <- reports |> 
    # On retire les rapports qui sont dupliqués
    dplyr::group_by(hash) |>
    dplyr::slice(1) |>
    dplyr::ungroup() |>
    # Si plusieurs extension de fichiers, on selectionne ceux en PDF préférablement, sinon .docx, sinon .doc en dernier recours.
    dplyr::group_split(id) |>
    purrr::map(\(g){
        g |> dplyr::arrange(factor(ext, levels = c('pdf', 'docx', 'doc'))) |>
        dplyr::slice(1)
    }) |>
    dplyr::bind_rows()
```

Quelques rapports de laboratoire demeurent au format doc et docx.

```{R, results='asis'}
docs <- reports |> dplyr::filter(ext %in% c('doc', 'docx')) 
docs |> knitr::kable()
```

Afin de faciliter l'extraction des métadonnées, on convertit les fichiers .doc et .docx en pdf

## Convertion des documents Word en pdf

Fonctionne seulement sur Microsoft Windows (testé sur v11), car cela requiert PowerShell pour effectuer la conversion.  



## Extraire les métadonnées du rapport

Nous souhaitons générer une liste de tous les projets basée sur les `r length(reports)` rapports de laboratoire stockés dans le dossier `03-Labo/Comptes rendus` de résultats. La première page de chaque rapport de laboratoire contient toutes les informations pertinentes pour produire cette liste.

Pour chaque rapport, nous vérifions s'il s'agit d'une image ou non. Si le rapport est une image, nous devons utiliser une reconnaissance optique de caractères (OCR) afin d'extraire le texte de la première page et d'obtenir toutes les métadonnées pertinentes. Si c'est un pdf ou un fichier word, nous importons la première page du document.

```{R, eval = FALSE}
reports <- reports |> dplyr::mutate(
    filename = basename(path),
    is_image = purrr::map2_lgl(path, ext, \(p, e) {
        if(e == "pdf"){
            out <- pdftools::pdf_text(p)
            !all(nchar(out) > 15)
        } else {
            FALSE
        }
    })
)

frontpages <- purrr::map2_vec(reports$paths, reports$is_image, \(p, i) {
        ifelse(isTRUE(i), 
            pdftools::pdf_ocr_text(pdf = p, pages = 1),
            pdftools::pdf_text(pdf = p)[[1]]
        )
    }) |> tolower()
```

```{R, eval = FALSE}
project_id <- purrr::map_vec(frontpages, \(f){
    stringr::str_extract(f, "(?<=(project: |project |projects|projet :)).*(?=\n)")
}) |> 
    toupper() |> 
    stringr::word(1) |> 
    stringr::str_replace_all("[.,]", "") |>
    stringr::str_trim()

project_leader <- purrr::map_vec(frontpages, \(f){
        stringr::str_extract(f, "(?<=(project leader: |project leader |project manager: |manager: |study leader: |nom du requérant :)).*(?=\n)")
    }) |> 
    stringr::str_replace_all(c("[_|:]" = "", "[:digit:]" = "", "[.]$" = "")) |> 
    stringr::str_to_title() |>
    stringr::str_trim()

project_title purrr::map_vec(frontpages, \(f){
        stringr::str_extract(f, "(?<=(program)).*(?=\n\n)")
    })

```

## Valider l'existence de rapports de laboratoire dans le dossier `01-Projet et suivis`

On valide si certains de ces rapports ne se retrouvent pas dans le dossier `03-Labo/Comptes rendus`. Ces rapports pourraient potentiellement nous interressés.

```{R, result = "asis"}
files <- list.files(
    "C:/Users/VissaultS/Documents/01-Projets et suivis", 
    pattern = "*.pdf|*.docx|*.doc", recursive = TRUE, full.names = TRUE
)

potential_reports <- data.frame(file = files[which(stringr::str_detect(files, regex_report_id))])

potential_reports <- potential_reports |> dplyr::mutate(
    id = stringr::str_extract(file, regex_report_id) |> toupper(),
    in_lab_report_folder = !(id %in% reports$id)
) |> dplyr::arrange(in_lab_report_folder) |>
    dplyr::mutate(file = stringr::str_replace(file, "C:/Users/VissaultS/Documents/", ""))

write.csv2(potential_reports, "reports_outside.csv", row.names = FALSE, fileEncoding = "UTF-8")

```
